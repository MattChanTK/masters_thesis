\chapter[Interactive Control System]
{Interactive Control System 
	\footnote{This chapter is adapted from papers submitted to IROS 2015 \cite{Chan2015} and Next Generation Building \cite{Gorbet2015}}} 
\label{chap:ctrl_system}

The CBLA requires a large increase in sensing and control capability which the previous versions of the Hylozoic Series embedded electronics \cite{Beesley2007.book} are unable to provide. A new Hylozoic Series 3 interactive control system was developed with re-designed hardware, to enable the control and sampling of a larger number of actuators and sensors at a higher frequency. 

To enable the sculpture to understand its own mechanisms, in addition to its surrounding environment and the occupants, there must be at least one proprioceptive sensor associated with each actuator. Note that while the nominal purpose of such a sensor is to directly sense the results of activation, they can also be used to detect changes in the environment.

This chapter discuss the design of the hardware mechanism that enable the learning algorithm behaviours, and some of the specific actuator and sensors that we use. 


\section{System Architecture}

In this implementation we opted for an architecture which a centralized computer controls a number of smaller localized microcontrollers that interface with the sensors and actuators. By running the high-level logics on a central computer, complex algorithm can quickly be developed without the constraints of a embedded platform. In addition, it provide an abstraction layer that enables the designer to build virtual sub-systems using any of the sensors and actuators. These two features allow us to quickly test out different configurations. On the other hand, by distributing the low-level logics on localized microcontrollers, the system can be more modular and the number of wires can be reduced. In addition, the real-time nature of the microcontrollers allows protection of sensitive actuators in case of central computer failure. 

\Cref{fig:system-architecture} shows the high-level system architecture of the Hylozoic Series 3 Interactive Control System. Each component runs asynchronously. At the bottom, there are the Teensy Devices. They represent the physical components in the sculptural system. Each Teensy Device consists of a Teensy Development Board \footnote{Teensy Development Board: \url{www.pjrc.com/teensy/teensy31.html}} and it communicates with a computer which hosts the abstract components via Universal Serial Bus (USB). Each controls and samples from a number of actuators and sensors. More details about the physical hardware are presented in \Cref{sec:hardware}. 

\begin{figure} [!htbp]
	\centering
	\includegraphics[height=0.90 \textheight]{"fig/interactive control system/high-level system architecture"}
	\caption[High-level system architecture]{The system is comprised of abstract and physical components. Each component run asynchronously in its own thread. Each arrow represents the data flow from one system to another.}
	\label{fig:system-architecture}
\end{figure}

For each Teensy Device, a Teensy Interface thread is created with the corresponding communication protocol and system parameters. Each type of Teensy Device has its own unique set of parameters that dictate or reflect the behaviours of its actuators or sensors respectively. Examples of some of the parameters are the brightness of an LED, and the readings from an accelerometer. The InteractiveCmd was created to provide an communication layer for all the physical components. Nodes can be created to control or sample any of the actuators and sensors through the InteractiveCmd. The InteractiveCmd handles the commands sent forth and forward them to the appropriate Teensy Interface in an efficient manner. A messenger was created to streamline the message delivery system. Its job is to periodically pushes all commands received from the abstract nodes in one package. This enables to the system to operate more efficiently by reducing the number of commands being sent to and received from InteractiveCmd. 

The Input Nodes and Output Nodes are the abstractions for sensors and actuators. Their sole purpose is to sample or update a particular sensor or actuator continuously. The second level of abstractions are the Device Nodes. Each Device Node is generally made up of one or more Input or Output Nodes, though Device Node can also be completely virtual. It provides additional functionality such as providing progressive dimming effect to the LED or calculating running average of a variable. The third the highest level of abstractions the CBLA Nodes. They are made up of components of Device Nodes. This is where the CBLA Engine and Prescripted Engine reside. The internal working of the CBLA Engine is discussed in \Cref{chap:cbla}. A Prescripted Engine is an alternate set of behaviours that follow a specially designed script, which does not involve any learning algorithm. A CBLA Node can be switched to either Engine while it is running. 

Data Logger is a special kind of abstract component that periodically samples the abstract variables of each abstract node, package the data in the memory, and save data in the hard disk in an efficient manner. The data collected are stored in a persistent key-value database for further analysis. In addition, the entire state of the CBLA Learners is also saved. This allows the the CBLA Nodes to recover from a previous state at a later time.


\section{Hardware} \label{sec:hardware}

The hardware are custom designed in collaboration with Mohammadreza Memarian. The goal is to develop a system that is modular, flexible and expandable. Analogue sensors and actuators that are traditionally used in previous Hylozoic Series as well as off-the-shelf sensors that interface via I2C, SPI, or UART are supported. Most importantly, it enables high-speed two-way communication with a computer using USB. Sensor reading and control signal can be delivered to and from a computer at around 100Hz. This capability allows us to run algorithms that are more computationally intensive, simplify the implementation of multi-threaded and multi-process software, and collect and display a large amount of data at run-time on a standard computer. 

\subsection{Actuators and Sensors}

The sensors and actuators used in the experiments described in \Cref{chap:validations} and their interface types are tabulated in \Cref{table:sensors-list} and \Cref{table:actuators-list} respectively.

\begin{table}[!htbp]
	\caption[List of sensors and their interface types]{List of sensors that are used in the experiments and their interface types}
	\begin{center}
		\begin{tabular}{ | c | c |} 
			\hline
			\textbf{Sensor} & \textbf{Interface Type} \\ 
			\hline
			IR proximity sensor\tablefootnote{Sharp GP2Y0A21YK Infrared Proximity Sensor:  \url{www.sharpsma.com/webfm_send/1208}} & Analogue  \\ 
			\hline
			Accelerometer\tablefootnote{ADXL345 3-Axis Digital Accelerometer: \url{	www.analog.com/media/en/technical-documentation/data-sheets/ADXL345.PDF}} & I2C \\
			\hline
			Ambient light sensor\tablefootnote{SparkFun Ambient Light Sensor Breakout (TEMT6000):  \url{www.sparkfun.com/products/8688}} & Analogue \\ 
			\hline
		\end{tabular}
	\end{center}
	\label{table:sensors-list}
\end{table}


\begin{table}[!htbp]
	\caption[List of actuator and their interface types]{List of actuators that are used in the experiments and their interface types}
	\begin{center}
		\begin{tabular}{ | c | c |} 
			\hline
			\textbf{Actuator} & \textbf{Interface Type} \\ 
			\hline
			Shape memory alloy (SMA) wire\tablefootnote{Dynalloy Flexinol Actuator Wire:  \url{www.dynalloy.com/tech_data_wire.php}} & PWM  \\ 
			\hline
			Vibration motor & PWM \\ 
			\hline			
			LED & PWM \\ 
			\hline		
			High-power LED\tablefootnote{Indus Star High-Power LED Light Module:  \url{www.luxdrive.com/content/A007_A008_Data_Sheet_V1.2.pdf}} & PWM \\ 
			\hline
		\end{tabular}
	\end{center}
	\label{table:actuators-list}
\end{table}

The aforementioned actuators and sensors interface with the Control Module through some special drivers. We call these drivers Device Modules. Different actuators or sensors require different Device Modules due to their different power requirements. They are plugged into the Device Ports on the Control Modules (discussed in \Cref{subsec:controller}). These Device Modules provide the power siwtching and voltage regulation needed to drive the actuators and sensors. 

Combinations of the actuators and sensors listed in \Cref{table:sensors-list,table:actuators-list} are used to form three functional units: 1) Fin Unit, which is composed of two SMA wires, and one infrared (IR) proximity sensor and a three-axis accelerometer; 2) Reflex Unit, which has a pair of LEDs (wired in together), and a vibration motor, and one infrared (IR) proximity sensors; and 3) Light unit, which comprises a high-power LED, and an ambient light sensor. Their spatial configurations are shown in \Cref{fig:Physical hardware}

\begin{figure}[!htbp]
	\centering
	\includegraphics[height=0.85 \textheight]{"fig/interactive control system/Physical hardware"}
	\caption[Typical spatial configuration of the physical functional units]{This is a typical spatial configuration of the function units (figure adapted from an image provided by Philip Beesley Architect Inc.). Bright green denotes actuators and bright red denotes sensors. Light Unit is shaded yellow; Fin Unit is shaded green; and Reflex Unit is shaded blue.}
	\label{fig:Physical hardware}
\end{figure}

A Fin Unit moves its 2-DOF Fin-like mechanism that is made of flexible plastic rods by controlling its two SMA wires. A Reflex Unit actuates its a vibration motors and mobilize the Frond-like mechanism attached to it. The pair of LEDs shine on to the Frond for additional effect. A Light Unit contains a very bright LED and it is hung high above on the sculpture. The IR proximity sensors detect the position of the occupants or objects within their ranges. The accelerometers detect contacts with the occupants and the deformations of the Fins. The ambient light sensors detect the light intensities of the ambient environment and their associated LEDs. 


\subsection{Control Modules}\label{subsec:controller}

At the heart of a Control Module, shown in \Cref{fig:Control_Module}, there is a Teensy 3 USB-based development board. It controls each device through the Device Port and communicate with the computer through USB as a human interface device (HID). Each Device Port has four output pins capable of pulse-width modulation (PWM), two input pins connecting to the Teensy's on-board analogue-to-digital converter (ADC), and two lines for digital serial communication over Inter-Integrated Circuit bus (I2C). It is designed to provide convenient and fast interface to commonly used analogue actuators and sensors, and a digital bus for added flexibility. 

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.68 \textwidth]{"fig/interactive control system/Control_Module"}
	\caption[Block diagram of the Control Module]{A Control Module is consisted of a Teensy 3, 6 Device Ports, a SPI port, and a UART port. Each Device port has 8 wires and they carry the signals that are commonly used in our system.}
	\label{fig:Control_Module}
\end{figure}

In order to increase the number of PWM pins beyond what provided natively on the Teensy, a I2C bus controlled PWM controller\footnote{PCA9685 16-channel, 12-bit PWM Fm$+$ I$^2$C-bus LED controller: \url{www.nxp.com/documents/data_sheet/PCA9685.pdf}} was used. This does not affect the I2C buses on the Device Ports since it is using one of Teensy's two I2C buses. The I2C bus for the Device Ports is further multiplexed into six. This makes each Device Port more independent, and devices may have the same addresses as long as they are on different buses. By have virtually six independent I2C buses, it simplifies the configuration of Device Modules as they can all be configured the same way.

\FloatBarrier
\section{Control Software}

The control software of the sculpture consists of a low-level layer and high-level layer. The two layers are connected via USB. The low-level layer consists of the firmware that interfaces with the peripherals that connect with the actuators and sensors. The high-level layer consists of the tools that facilitate communication between the two layers and the application that dictates the system behaviour. The abstraction provided by the high-level layer allows flexibility in defining the nodes and their relationship to each other. 

\subsection{Communication and Interface}

A low-level layer of firmware written in C++ runs on the Teensy 3 USB-based development boards which interface with the peripherals that connect with the actuators and sensors.  High-level software written in Python is referred to as applications, and runs on a central computer. The use of the central computer as a development platform provides flexibility for development free from the limited processing power and specialized functions inherent to the Teensy microcontroller hardware. Moreover, Python is cross-platform and supports multi-threading, permitting operation within many operating systems and allowing multiple sets of software instructions to be executed in parallel. Code that is necessary for communicating with the low-level layer is packed into a Python Package named interactive-system. Developers can then develop applications that control and retrieve information from the sculptural system firmware using the software utilities provided by the Python Package. Each application can run on its own thread. While care should be exercised to avoid conflicts among threads, this should permit multiple applications to execute simultaneously.	

The CBLA executes as an application that communicates with the low level using the interactive-system Python package. Other applications such as an occupancy map that uses the sensors on the sculpture to interpret the locations of the occupants can run simultaneously, taking advantage of the multi-threading properties of the high-level platform.

\Cref{fig:Teensy Interface Thread} illustrates how an application communicates with the Teensy devices. At the high-level layer, the Teensy Interface module in the interactive-system package is used to create a thread for each Teensy device. The thread looks for changes in those parameters and performs synchronization. Each Teensy device on the low-level layer is represented by a Teensy Interface thread on the high-level layer. An InteractiveCmd thread can modify a Teensy’s output parameters and retrieve its input parameters through its Teensy Interface.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1.0 \textwidth]{"fig/interactive control system/Teensy Interface Thread"}
	\caption[Illustration of the working of the Teensy Interface]{Teensy Interface is the connection between the InteractiveCmd and its associated Teensy device. InteractiveCmd modifies output parameters on its corresponding Teensy Interface's output hash table. This triggers an event that pushes the changes to the Teensy device. The Teensy device would then respond by triggering an event that updates the input hash table with newly sampled input values and notifies the InteractiveCmd.}
	\label{fig:Teensy Interface Thread}
\end{figure}

\FloatBarrier
\subsection{Node Abstraction}

To make constructing node more flexible, nodes can be constructed in any combinations of actuators, sensors, or other virtual devices. Each device, physical or virtual is represented as a variable in the memory. Figure shows an example of this node abstraction system would work.

%TODO Needs a figure

The addition of  "Messanger" node streamline the communication. That is because each packet can contain 64 bytes. If each nodes which might all be on one single Teensy, it might try to send information that are only requiring one bytes. By combining message destined to one Teensy together, it can be faster. True that this means that data won't be delivered at fastest possible time and it must wait for the next delivery cycle. Therefore, the rate of each CBLA node was set to be at least 3 times the messenger's update period to ensure that no command is missed. 
If a node is running too fast, it will have to wait. 

For instance, a device might be a LED but one can only set the desired brightness and it will ramp up to the desired brightness rather than going to that level immediately. This abstracted system makes developing CBLA node much simply and enable complex control software to be hidden from the CBLA code which greatly simplify the code. 

\FloatBarrier
\section{Data Collections}

The system a large set of asynchronous threads that changes at their own speeds. We need to collect the timing and the output and inputs of every variable and also internal variable within the CBLA engine. In addition, we also need to store the state of the CBLA Learner in order to cover that at a later time. 

This large amount of data are handle in such a way that does not slow down the system and yet provide security in case when the program fail unexpectedly. Also, the data must be saved to disk as CBLA can be expected to be run for long time and memory won't be enough to store all data. 
Figure show the flowchart of the Data collection process

due to the asynchronous, variant nature of the node (many different types of variable sets and non-numerical values)and the large and expanding hierarchy of the CBLA Engine (number of CBLA engine expands over time), it cannot simply be saved at table. In this case, we use a key-value type data base. We store the data as binary in form of pickled data as python object. this allows flexibility in handling different datatype and the deep hierarchy. 

A special script is required to extract the data for analysis when needed. 

