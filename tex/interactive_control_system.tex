\chapter[Interactive Control System]
{Interactive Control System 
	\footnote{Part of this chapter is adapted from papers submitted to IROS 2015 \cite{Chan2015} and Next Generation Building \cite{Gorbet2015}}} 
\label{chap:ctrl_system}

The CBLA requires a large increase in sensing and control capability which the previous versions of the Hylozoic Series embedded electronics \cite{Beesley2010} are unable to provide. A new Hylozoic Series 3 interactive control system was developed with re-designed hardware, to enable the control and sampling of a larger number of actuators and sensors at a higher frequency. 

To enable the sculpture to understand its own mechanisms, in addition to its surrounding environment and the occupants, there must be at least one proprioceptive sensor associated with each actuator. Note that while the nominal purpose of such a sensor is to directly sense the results of activation, they can also be used to detect changes in the environment.

This chapter discuss the design of the hardware and software mechanism that enable the learning algorithm behaviours, and some of the specific actuator and sensors that we use. 


\section{System Architecture}

In this implementation, we opted for an architecture which a centralized computer controls a number of smaller localized microcontrollers that interface with the sensors and actuators. By running the high-level logics on a central computer, complex algorithm can quickly be developed without the constraints of a embedded platform. In addition, it provides an abstraction layer that enables the designer to build virtual sub-systems using any of the sensors and actuators. These two features allow us to quickly test out different configurations. On the other hand, by distributing the low-level logics on localized microcontrollers, the system can be more modular and the number of wires can be reduced. In addition, the real-time nature of the microcontrollers allows protection of sensitive actuators in case of central computer failure. 

\Cref{fig:system-architecture} shows the high-level system architecture of the Hylozoic Series 3 Interactive Control System. Each component runs asynchronously. At the bottom, there are the Teensy Devices. They represent the physical components in the sculptural system. Each Teensy Device consists of a Teensy Development Board \footnote{Teensy Development Board: \url{www.pjrc.com/teensy/teensy31.html}} and it communicates with a computer which hosts the abstract components via Universal Serial Bus (USB). Each controls and samples from a number of actuators and sensors. More details about the physical hardware are presented in \Cref{sec:hardware}. 

\begin{figure} [!htbp]
	\centering
	\includegraphics[height=0.90 \textheight]{"fig/interactive control system/high-level system architecture"}
	\caption[High-level system architecture]{The system is comprised of abstract and physical components. Each component runs asynchronously in its own thread. Each arrow represents the data flow from one system to another.}
	\label{fig:system-architecture}
\end{figure}

For each Teensy Device, a Teensy Interface thread is created with the corresponding communication protocol and system parameters. Each type of Teensy Device has its own unique set of parameters that dictates or reflects the behaviours of its actuators or sensors respectively. Examples of some of the parameters are the brightness of an LED, and the readings from an accelerometer. The InteractiveCmd was created to provide a communication layer for all the physical components. Nodes can be created to control or sample any of the actuators and sensors through the InteractiveCmd. The InteractiveCmd handles the commands sent forth and forward them to the appropriate Teensy Interface in an efficient manner. A Messenger was created to streamline the message delivery system by periodically pushing commands received from the abstract Nodes in a more compressed form. This reduces the number of commands being sent to and received from InteractiveCmd and, thus, enables the system to operate more efficiently.

The Input Nodes and Output Nodes are the abstractions for sensors and actuators. Their sole purpose is to sample or update a particular sensor or actuator continuously. The second level of abstractions are the Device Nodes. Each Device Node is generally made up of one or more Input or Output Nodes, though it can also be completely virtual. It provides additional functionalities such as providing progressive dimming effect to the LEDs, or calculating running average of a variable. The third level of abstractions are the CBLA Nodes. They are made up of components of the Device Nodes. This is also where the CBLA Engine and Prescripted Engine reside. The internal working of the CBLA Engine is discussed in \Cref{chap:cbla}. A Prescripted Engine is an alternate set of behaviours that follow specially designed scripts, and do not involve any learning algorithm. A CBLA Node can be switched to either Engine while it is running. 

Data Logger is a special kind of abstract component that periodically samples the abstract variables of each abstract node, package the data in the memory, and save data in the hard drive in an efficient manner. The data collected are stored in a persistent key-value database for further analysis. In addition, the entire state of the CBLA Engine is also saved. This allows the CBLA system to recover from a previous state at a later time.


\section{Hardware} \label{sec:hardware}

The hardware are custom designed in collaboration with Mohammadreza Memarian. The goal is to develop a system that is modular, flexible, and expandable. Analogue sensors and actuators that are traditionally used in previous Hylozoic Series as well as off-the-shelf sensors that interface via I2C, SPI, or UART are supported. Most importantly, it enables high-speed two-way communication with a computer over USB. Sensor readings and control signals can be delivered to and from a computer at around 100Hz. This capability allows us to run algorithms that are more computationally intensive; simplify the implementation of multi-threaded and multi-process software; and collect and display a large amount of data at runtime on a standard computer. 

\subsection{Actuators and Sensors}

The sensors and actuators used in the experiments described in \Cref{chap:validations} and their interface types are tabulated in \Cref{table:sensors-list} and \Cref{table:actuators-list} respectively.

\begin{table}[!htbp]
	\caption[List of sensors and their interface types]{List of sensors that were used in the experiments and their interface types}
	\begin{center}
		\begin{tabular}{ | c | c |} 
			\hline
			\textbf{Sensor} & \textbf{Interface Type} \\ 
			\hline
			IR proximity sensor\tablefootnote{Sharp GP2Y0A21YK Infrared Proximity Sensor:  \url{www.sharpsma.com/webfm_send/1208}} & Analogue  \\ 
			\hline
			Accelerometer\tablefootnote{ADXL345 3-Axis Digital Accelerometer: \url{	www.analog.com/media/en/technical-documentation/data-sheets/ADXL345.PDF}} & I2C \\
			\hline
			Ambient light sensor\tablefootnote{SparkFun Ambient Light Sensor Breakout (TEMT6000):  \url{www.sparkfun.com/products/8688}} & Analogue \\ 
			\hline
		\end{tabular}
	\end{center}
	\label{table:sensors-list}
\end{table}


\begin{table}[!htbp]
	\caption[List of actuators and their interface types]{List of actuators that were used in the experiments and their interface types}
	\begin{center}
		\begin{tabular}{ | c | c |} 
			\hline
			\textbf{Actuator} & \textbf{Interface Type} \\ 
			\hline
			Shape memory alloy (SMA) wire\tablefootnote{Dynalloy Flexinol Actuator Wire:  \url{www.dynalloy.com/tech_data_wire.php}} & PWM  \\ 
			\hline
			Vibration motor & PWM \\ 
			\hline			
			LED & PWM \\ 
			\hline		
			High-power LED\tablefootnote{Indus Star High-Power LED Light Module:  \url{www.luxdrive.com/content/A007_A008_Data_Sheet_V1.2.pdf}} & PWM \\ 
			\hline
		\end{tabular}
	\end{center}
	\label{table:actuators-list}
\end{table}

The aforementioned actuators and sensors interface with the Control Module through some special drivers. We call these drivers Device Modules. Different actuators or sensors require different Device Modules due to their different power requirements. They are plugged into the Device Ports on the Control Modules (discussed in \Cref{subsec:controller}). These Device Modules provide the power switching and voltage regulation needed to drive the actuators and sensors. 

Combinations of the actuators and sensors listed in \Cref{table:sensors-list,table:actuators-list} are used to form three functional units: 1) Fin Unit, which is composed of two SMA wires, one infrared (IR) proximity sensor, and a three-axis accelerometer; 2) Reflex Unit, which has a pair of LEDs (wired in together), a vibration motor, and one infrared (IR) proximity sensors; and 3) Light unit, which comprises a high-power LED, and an ambient light sensor. Their spatial configurations are shown in \Cref{fig:Physical hardware}

\begin{figure}[!htbp]
	\centering
	\includegraphics[height=0.85 \textheight]{"fig/interactive control system/Physical hardware"}
	\caption[Typical spatial configuration of the physical functional units]{This is a typical spatial configuration of the function units (figure adapted from an image provided by Philip Beesley Architect Inc.). Bright green denotes actuators and bright red denotes sensors. Light Unit is shaded yellow; Fin Unit is shaded green; and Reflex Unit is shaded blue.}
	\label{fig:Physical hardware}
\end{figure}

A Fin Unit moves its 2-DOF Fin-like mechanism that is made of flexible plastic rods by controlling its two SMA wires. A Reflex Unit actuates its a vibration motors and mobilizes the Frond-like mechanism attached to it. The pair of LEDs shine on to the Frond for additional effect. A Light Unit contains a very bright LED and it is hung high above on the sculpture. The IR proximity sensors detect the position of the occupants or objects within their ranges. The accelerometers detect contacts with the occupants and the deformations of the Fins. The ambient light sensors detect the light intensities of the ambient environment and their associated LEDs. 


\subsection{Control Modules}\label{subsec:controller}

At the heart of a Control Module, shown in \Cref{fig:Control_Module}, there is a Teensy 3 USB-based development board. It controls each device through the Device Port and communicates with the computer through USB as a human interface device (HID). Each Device Port has four output pins capable of pulse-width modulation (PWM), two input pins connecting to the Teensy's on-board analogue-to-digital converter (ADC), and two lines for digital serial communication over Inter-Integrated Circuit bus (I2C). It is designed to provide convenient and fast interface to commonly used analogue actuators and sensors, and a digital bus for added flexibility. The on-board SPI and UART port are reserved for future expansion.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.68 \textwidth]{"fig/interactive control system/Control_Module"}
	\caption[Block diagram of the Control Module]{A Control Module is consisted of a Teensy 3, 6 Device Ports, a SPI port, and a UART port. Each Device port has 8 wires and they carry the signals that are commonly used in our system.}
	\label{fig:Control_Module}
\end{figure}

In order to increase the number of PWM pins beyond what is provided natively on the Teensy, a I2C bus controlled PWM controller\footnote{PCA9685 16-channel, 12-bit PWM Fm$+$ I$^2$C-bus LED controller: \url{www.nxp.com/documents/data_sheet/PCA9685.pdf}} was used. This does not affect the I2C buses on the Device Ports since it is using the other one of Teensy's two I2C buses. The I2C bus for the Device Ports is further multiplexed into six. This makes each Device Port more independent, and devices may have the same addresses as long as they are on different Device Ports. By having virtually six independent I2C buses, it simplifies the configuration of the Device Modules as they can all be configured the same way.

\FloatBarrier
\section{Control Software}

The control software of the sculpture consists of a low-level layer and high-level layer. The two layers are connected via USB. The low-level layer consists of the firmware that interfaces with the peripherals that connect with the actuators and sensors. The high-level layer consists of the tools that facilitate communication between the two layers and the application that dictates the system behaviour. The abstraction provided by the high-level layer allows flexibility in defining the nodes and their relationships to each other. 

\subsection{Communication and Interface}

A low-level layer of firmware written in C++ runs on the Teensy 3 USB-based development boards which interface with the peripherals that connect with the actuators and sensors. High-level software written in Python 3.4 is referred to as applications, and runs on a central computer. The use of the central computer as a development platform provides flexibility for development free from the limited processing power and specialized functions inherent to the Teensy microcontroller hardware. Moreover, Python 3.4 is cross-platform and supports multi-threading, permitting operation within many operating systems and allowing multiple sets of software instructions to be executed in parallel. Code that is necessary for communicating with the low-level layer is packed into a Python Package named \textit{interactive-system}. Developers can then develop applications that control and retrieve information from the sculptural system firmware using the software utilities provided by the Python Package. Each application can run on its own thread. While care should be exercised to avoid conflicts among threads, this should permit multiple applications to execute simultaneously.	

CBLA executes as an application that communicates with the low-level layer using the \textit{interactive-system} Python package. Other applications such as an occupancy map that uses the sensors on the sculpture to interpret the locations of the occupants can run simultaneously, taking advantage of the multi-threading properties of the high-level platform.

\Cref{fig:TeensyInterface Thread} illustrates how an application communicates with the Teensy devices. At the high-level layer, the Teensy Interface module in the \textit{interactive-system} package is used to create a thread for each Teensy device. The thread looks for changes in those parameters and performs synchronization. Each Teensy device on the low-level layer is represented by a Teensy Interface thread on the high-level layer. Teensy devices are considered as slave devices in this communication mechanism. Only the Teensy Interface, the Master, can initiate a read or write request. An InteractiveCmd thread can modify a Teensy's output parameters and retrieve its input parameters through its Teensy Interface. 

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.9 \textwidth]{"fig/interactive control system/TeensyInterface Thread"}
	\caption[Illustration of the working of the Teensy Interface]{Teensy Interface is the connection between the InteractiveCmd and its associated Teensy device. InteractiveCmd modifies output parameters on its corresponding Teensy Interface's output hash table. This triggers an event that pushes the changes to the Teensy device. The Teensy device would then respond by triggering an event that updates the input hash table with newly sampled input values and notifies the InteractiveCmd.}
	\label{fig:TeensyInterface Thread}
\end{figure}

\FloatBarrier
\subsection{Node Abstraction}

Between the Nodes and the Teensy Interface, there is the InteractiveCmd. Its job is to forward messages to the correct Teensy Interface and hides the physical implementation of the low-level layer devices from the Nodes. In addition, since the InteractiveCmd module enables the control and sampling of any actuators and sensors in the system, a Node can be constructed unconstrained by spatial or hardware confines. Each Node, physical or virtual, is represented by a set of input and output variables which can be accessed by any other nodes in the system, and each runs continuously in its own thread. Input variables are simply variables in the memory that Nodes have read access to. Similarly, output variables are variables that Nodes have write access to. Multiple Nodes can share one input variable while only one Node can be associated with one output variable. \Cref{fig:Node_abstraction} illustrates the relationships between different Nodes. 

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1.0 \textwidth]{"fig/interactive control system/Node_abstraction"}
	\caption[Illustration of how abstract nodes work]{Illustration of how abstract nodes work. Each rectangle represents a thread. The purple one represent InteractiveCmd and Each of the green ones represents a Node. The blue circle represents a variable in the memory. The arrow represents the direction of access. Multiple Nodes can share read access to a variable while only one Node can have write access to one variable.}
	\label{fig:Node_abstraction}
\end{figure}

At the lowest level, Input Nodes continuously updates their associated variables and Output Nodes continuously send output requests to InteractiveCmd through the Messenger. Different types of Input and Output nodes are specially configured to run at a loop period compatible with the physical components that they represent. This mechanism makes implementation of the higher level Nodes much easier by eliminating the need of communicating with the InteractiveCmd by means of sending individual messages. Instead, each of the inputs and outputs variables can be accessed from the memory at any time. These variables are used as building blocks for higher level Nodes. In addition, intermediate level Nodes can embed extra functionalities. For instance, a LED Driver ramps up or dims an LED to the desired brightness level. A higher-level Node controlling that LED using the LED Driver can the operate at a lower update period and process more complex logics. This Node Abstraction system makes developing CBLA Nodes much simpler by eliminating the need of managing logics requiring different frequencies of control under one thread. 

The addition of Messenger node between the InteractiveCmd, and Input and Output Nodes streamlines the communication by reducing the number of messages. Over USB, each packet can contain up to 64 bytes. If each Node communicates with the InteractiveCmd directly, there will be many messages that might only require one or two bytes. A large portion of the communication bandwidth will be wasted and the update rate of the Nodes will be significantly throttled. Since many messages are likely to be delivered to the same Teensy, those messages can be combined and delivered as a single packet. The job of the Messenger Node is to collect all the messages, combine them appropriately, and deliver them to the InteractiveCmd periodically. Although this means that each message must wait for the next delivery cycle to be sent out, this mechanism allows the system to handle a much higher throughput. To avoid commands or requests being missed, the rate of each Input or Output node is set to be at least three times the Messenger's update period. 


\FloatBarrier
\section{Data Logging}

For secondary analysis, the timings and the values of all inputs and output variables of every Node, as well as the internal variables within CBLA Engine must be collected and stored onto the hard drive. In addition, the state of the CBLA Learner including all the exemplars, the predictions models, and the definitions of the regions must be stored such that it can be recovered at a later time. 

The CBLA system contains a large number of asynchronous threads that run at their own speeds. As a result, a large amount and variety of data are generated at high frequencies and at different times. These data must be handled in such a way that does not slow down the system. In addition, in case when the program fail to terminate safely, the majority of the data should still be recoverable. Also, the data must be saved to disk and be discarded from the memory continuously as the CBLA system is expected to operate for a long period of time.

\subsection{Key-Value Database}
 
The data generated by the Nodes are in many different types, such as integer, floating point, string, list, tuple, and other custom object types. In addition, objects such as the CBLA Learner are continuously expanding and its hierarchy gets deeper over time. Moreover, each type of data packet gets generated at different non-constant time cycles. This makes simply saving them in a table or a relational database impractical. In our implementation, a simple key-value type NoSQL database based on Python's shelve\footnote{Python shelve documentation: \url{https://docs.python.org/3.4/library/shelve.html}} module was used. In shelve, the data are stored as serialized Python object using the pickle\footnote{Python pickle documentation: \url{https://docs.python.org/3.4/library/pickle.html}} module. This type of database gives the flexibility of storing an assortment of data types without the need of predefining them. However, since the data are not stored as plain text, a special script is required to extract the data in the desired formats for offline analysis. 

\subsection{Database Structure}

Each time the CBLA System is run, a new shelve database is created for the session. This is to ensure that data from previous sessions would not get corrupted accidentally. In addition, in order to restart from a previous session, one only has to remove the database files of the succeeding sessions. If there are previous sessions, the CBLA system will access an index file to locate the database file of the most recent session and retrieve information regarding the previous state of the system. Information about the start time, end time, and the configurations of the system can also be found in the index file. \Cref{fig:data_structure} illustrates the structure of the database created by the Data Logger. 

\begin{figure}
	\dirtree{%
		.1 Session 1.
		.2 Node A.
		.3 Info Type.
		.4 S names: (IR Sensor 0, IR Sensor 1, ...).
		.4 M names: (LED, Vibration Motor, ...).
		.4 CBLA State.
		.5 Step Count: 245.
		.5 Experts.
		.6 Expert IDs: (0, 3, ...).
		.6 Mean Errors: (0.1, 0.001, ...).
		.6 Prediction Models: (linreg obj 1, linreg obj 2, ...).
		.6 ....
		.5 Robot: reflex\_robot obj.	
		.5 ....
		.4 ....
		.3 Packet Type.
		.4 t = 1.00s.
		.5 packet (t = 1.001s).
		.6 S: (10, 1024, 20, ...).
		.6 M: (0, 140, 255, ...).
		.6 Relative Action Value: 10.
		.6 ....
		.5 packet (t = 1.002s).
		.5 ....
		.4 t = 1.01s.
		.4 ....
		.2 Node B.
		.2 ....
	}
	\dirtree{%
		.1 Session 2.
	}
	\dirtree{%
		.1 ....
	}
	\caption[Structure of the database created by Data Logger]{Example showing the structure of the database created by the Data Logger .}
	\label{fig:data_structure}
\end{figure}

For each Node, there are two main types of data: Packet Type and Info Type. Each Packet Type data has a timestamp which indicates when the data block is generated. These data blocks are generated continuously and they must all be stored. It contains information about the sensor readings, actuator outputs, and the internal parameters of the CBLA Engine such as its current mean error, number of regions, and relative action values. Packet Type data are mainly used for secondary analysis purposes. On the other hand, Info Type data describes the system and does not have a timestamp. When new versions of Info Type data arrive, the old ones can be overwritten. Information like the names and order of the sensor and actuator variables, which do not change over the runtime of the system, are Info Type data. In addition, the state of the CBLA Engine, which is needed for recovering from a later time, is also an Info Type data. Over the long term, while it is desirable for the state to be saved frequently, the size of the data that describes it would become too large to allow multiple copies of it to be stored. By saving it as an Info Type, old version can simply be overwritten by a newer version.

\subsection{Data Logging Process}

Due to the large amount of data that are being generated at high frequencies, saving each block of data directly would require too much time and introduce significant lag in the system. Therefore, a multi-stage process as illustrated in \Cref{fig:DataLogger process} is used to improve data logging efficiency.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1.0 \textwidth]{"fig/interactive control system/DataLogger process"}
	\caption[Flowchart of the data logging process]{Flowchart of the data logging process from data generation to writing to the disk.}
	\label{fig:DataLogger process}
\end{figure}

Packet Type data blocks are being generated at a rate of approximately one block every 20 milliseconds per Node. This is relatively high given the hundreds of Nodes that a typical CBLA system has. On the other hand, Info Type data are being generated at a much slower rate at roughly one data block every two minutes per Node. Both types of data blocks would first get enqueued onto the Data Logger first before being transferred to the Data Saver which is the module responsible for writing the data into the shelve database. This step is necessary to avoid slowing down the CBLA Nodes because Data Saver is a separate process, and transferring data to another Process takes significantly longer time than to another thread. 

For the higher frequency Packet Type data blocks, instead of directly being sent to the Data Saver, they are first being packed in Packet Arrays. This process decreases the total transfer time to the Data Saver by drastically lowering the number of enqueue calls which have some non-trivial overheads. There is one Packet Array for each Node and they get enqueued to the Data Saver periodically. 

The Data Saver is implemented as a process in order to avoid the GIL limitation imposed by Python \cite{Beazley2010}. This enables the system to make use of the parallel computing capability of a multi-core computer. Although transferring data to a process takes longer as it requires the copying of the actual data rather than just the pointers, it is still faster than writing the data onto the disk. Therefore, it is still more efficient to move the data and let a separate process load the data onto the database.

Nevertheless, depending on the number of Nodes in the system, there are situations when data are indeed being generated at a rate faster than it can be stored. Eventually, over the long term, the memory of the host computer will be full and the program will crash. In addition, a long wait time between data generation and data storage means that if the program crashes unexpectedly, a large amount of data would be lost. To avoid crashing and the loss of data, once the length of the queue has reached a certain threshold, a clean-up procedure would be activated. It momentarily pauses all other threads, and allocates all the processing power for the purposes of data storage. Practically, this process would only takes around 50 to 70 milliseconds. Since it happens only once every few minutes, it is generally not noticeable by human viewer. In fact, the reason why it only takes so little time is because, by pausing all other threads, it eliminates the overhead of thread switching. This process ensures that the CBLA system can operate as long as there are sufficient storage space on the hard drive of the host computer. 

